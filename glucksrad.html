<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Glücksrad — Namen-Roulette</title>
  <style>
    :root{--bg:#0f172a;--card:#0b1220;--accent:#f59e0b;color-scheme:dark}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#071020 0%,#0b1220 100%);color:#e6eef8;display:flex;min-height:100vh;align-items:center;justify-content:center;padding:24px}
    .app{max-width:1100px;width:100%;display:grid;grid-template-columns:560px 1fr;gap:20px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));border-radius:12px;padding:18px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    h1{margin:0 0 6px;font-size:20px}
    p.sub{margin:0 0 12px;color:#9fb2d6;font-size:13px}
    .wheel-wrap{display:flex;flex-direction:column;align-items:center;gap:12px}
    canvas#wheel{border-radius:50%;background:transparent}
    .pointer{width:0;height:0;border-left:18px solid transparent;border-right:18px solid transparent;border-bottom:26px solid var(--accent);margin-top:-8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button, input[type="text"], textarea{font:inherit}
    .btn{background:var(--accent);border:none;padding:10px 14px;border-radius:10px;color:#071022;cursor:pointer;font-weight:600}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8}
    .btn.danger{background:#ef4444;color:white}
    .result{min-height:56px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:700}
    .inputs{display:flex;flex-direction:column;gap:10px}
    textarea#names{width:100%;min-height:220px;padding:12px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit}
    .small{font-size:13px;color:#9fb2d6}
    .list{max-height:220px;overflow:auto;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(0,0,0,0.02))}
    .list div{padding:6px 8px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.01);display:flex;justify-content:space-between;align-items:center}
    .list button{background:transparent;border:0;color:#ffef;cursor:pointer}
    .footer{margin-top:10px;font-size:12px;color:#9fb2d6}
    .tests{margin-top:12px;border-top:1px dashed rgba(255,255,255,0.04);padding-top:12px}
    pre#testOutput{background:rgba(0,0,0,0.18);padding:8px;border-radius:8px;white-space:pre-wrap}
    @media (max-width:980px){.app{grid-template-columns:1fr;max-width:760px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card wheel-wrap">
      <h1>Glücksrad</h1>
      <p class="sub">Gib Namen ein (rechts), klicke auf <strong>Spin</strong> und das Rad wählt einen zufällig aus.</p>

      <div style="display:flex;flex-direction:column;align-items:center">
        <canvas id="wheel" width="520" height="520" aria-label="Glücksrad"></canvas>
        <div class="pointer" aria-hidden></div>
      </div>

      <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px">
        <div class="controls">
          <button id="spinBtn" class="btn">Spin</button>
          <button id="addRandomBtn" class="btn secondary">Zufällige Namen</button>
          <button id="clearBtn" class="btn secondary">Leeren</button>
        </div>
        
      </div>

      <div class="footer">Download: <button id="downloadBtn" class="btn secondary">HTML-Datei</button></div>

      <div class="tests">
        <button id="runTests" class="btn secondary">Selbstcheck ausführen</button>
        <div style="margin-top:8px"><strong>Testergebnis:</strong></div>
        <pre id="testOutput">(keine Tests ausgeführt)</pre>
      </div>
    </div>

    <div class="card inputs">
      <div>
        <label for="names"><strong>Namen (1 pro Zeile)</strong></label>
        <textarea id="names" placeholder="Eintrag pro Zeile, z. B.\nAnna\nBernd\nCem"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="applyBtn" class="btn">Anwenden</button>
          <button id="shuffleBtn" class="btn secondary">Mischen</button>
        </div>
        <div class="small" style="margin-top:8px">Tipp: Du kannst Namen direkt in die Liste schreiben oder durch Kommas trennen, dann auf <em>Anwenden</em> klicken.</div>
      </div>

      <div>
        <label><strong>Aktuelle Namen</strong></label>
        <div id="list" class="list">(keine Namen)</div>
      </div>

      <div>
        <label><strong>Einstellungen</strong></label>
        <div style="display:flex;gap:8px;margin-top:6px;align-items:center">
          <label class="small">Glättung: <input id="slicesSmooth" type="range" min="0" max="1" step="0.01" value="0.2"></label>
          <label class="small">Schriftgröße: <input id="fontSize" type="number" min="10" max="28" value="14" style="width:72px;margin-left:6px"></label>
        </div>
      </div>

    </div>
  </div>

  <script>
    // --- Elements & state
    const canvas = document.getElementById('wheel');
    const ctx = canvas.getContext('2d');
    let names = [];
    const colors = [];

    const namesEl = document.getElementById('names');
    const applyBtn = document.getElementById('applyBtn');
    const listEl = document.getElementById('list');
    const spinBtn = document.getElementById('spinBtn');
    const clearBtn = document.getElementById('clearBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const addRandomBtn = document.getElementById('addRandomBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const fontSizeInput = document.getElementById('fontSize');
    const runTestsBtn = document.getElementById('runTests');
    const testOutput = document.getElementById('testOutput');

    let angle = 0; // current rotation of the wheel (radians)
    let angularVelocity = 0; // radians per frame
    let isSpinning = false;
    let isSnapping = false; // when we animate to exact slice center

    const TAU = Math.PI * 2;
    const POINTER = -Math.PI/2; // fixed pointer at the top of the canvas

    // --- Helpers
    function randColor(i){
      const h = (i * 137.508) % 360;
      return `hsl(${h} 75% 55%)`;
    }
    function updateColors(){ colors.length = 0; for(let i=0;i<names.length;i++) colors.push(randColor(i)); }
    function mod(a,m){ return ((a % m) + m) % m; }

    // --- Drawing
    function draw(){
      const w = canvas.width, h = canvas.height, cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
      ctx.clearRect(0,0,w,h);
      if(names.length===0){
        ctx.save(); ctx.translate(cx,cy);
        ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.beginPath(); ctx.arc(0,0,r,0,TAU); ctx.fill();
        ctx.fillStyle = '#9fb2d6'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='16px sans-serif'; ctx.fillText('Keine Namen',0,0);
        ctx.restore();
        return;
      }

      const slice = TAU / names.length;
      ctx.save(); ctx.translate(cx,cy); ctx.rotate(angle);

      for(let i=0;i<names.length;i++){
        const start = i*slice;
        const end = start + slice;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,r,start,end); ctx.closePath();
        ctx.fillStyle = colors[i%colors.length]; ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)'; ctx.lineWidth = 1; ctx.stroke();

        // text
        ctx.save(); const mid = (start+end)/2; ctx.rotate(mid + Math.PI/2); ctx.translate(0, -r*0.68); ctx.rotate(Math.PI/2);
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const fsize = parseInt(fontSizeInput.value || 14,10); ctx.font = `${fsize}px sans-serif`;
        wrapText(ctx, names[i], 0, 0, r*0.5, fsize+2);
        ctx.restore();
      }

      // center circle
      ctx.beginPath(); ctx.arc(0,0,r*0.18,0,TAU); ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.fill();
      ctx.restore();
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight){
      const words = text.split(' '); let line=''; const lines=[];
      for(let n=0;n<words.length;n++){ const testLine = line ? line + ' ' + words[n] : words[n]; if(ctx.measureText(testLine).width > maxWidth && n>0){ lines.push(line); line = words[n]; } else { line = testLine; } }
      lines.push(line);
      const totalHeight = lines.length * lineHeight; let offsetY = -totalHeight/2 + lineHeight/2;
      for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], x, y + offsetY + i*lineHeight);
    }

    // --- Winner detection
    // Given the current wheel rotation (angle), determine which index is under the fixed pointer (top)
    function findIndexUnderPointer(atAngle){
      if(names.length === 0) return -1;
      const slice = TAU / names.length;
      const normalized = mod(POINTER - atAngle, TAU);
      const idx = Math.floor(normalized / slice) % names.length;
      return idx;
    }

    function playMeow(){
      // Versuche zuerst die SpeechSynthesis-API (spricht "miau"), Fallback auf WebAudio
      try{
        if('speechSynthesis' in window){
          const u = new SpeechSynthesisUtterance('miau');
          u.lang = 'de-DE';
          u.rate = 1.15;
          u.pitch = 1.6;
          // cancel any ongoing speech to keep sounds snappy
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(u);
          return;
        }
      }catch(e){}
      // Fallback: kurzer "miau"-ähnlicher Ton mit WebAudio
      try{
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine';
        // Start high, slide down to give a "meow" character
        o.frequency.setValueAtTime(750, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.35);
        g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.8, audioCtx.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{ try{ o.stop(); audioCtx.close(); }catch(e){} }, 550);
      }catch(e){}
    }

    function announceWinner(forcedIndex = null){
      let index = forcedIndex;
      if(index === null){ index = findIndexUnderPointer(angle); }
      if(index < 0 || index >= names.length){ return; }
      // visual pulse
      try{ canvas.animate([{filter:'brightness(1)'},{filter:'brightness(1.25)'},{filter:'brightness(1)'}],{duration:700}); }catch(e){}
      // spiele das "miau"-Geräusch
      try{ playMeow(); }catch(e){}
    }

    // Smoothly snap wheel so chosen index is centered under the pointer
    function snapToIndex(index, duration = 700){
      isSnapping = true; spinBtn.disabled = true;
      const slice = TAU / names.length;
      const mid = index * slice + slice/2; // mid angle of the slice in wheel coords
      let target = mod(POINTER - mid, TAU);

      // pick the closest equivalent target to current angle
      let current = angle;
      while(target - current > Math.PI) target -= TAU;
      while(target - current < -Math.PI) target += TAU;

      const start = current; const delta = target - start; const t0 = performance.now();
      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
      function step(now){ const p = Math.min(1, (now - t0) / duration); const eased = easeOutCubic(p); angle = start + delta * eased; if(p < 1) requestAnimationFrame(step); else { angle = target; isSnapping = false; spinBtn.disabled = false; announceWinner(index); } }
      requestAnimationFrame(step);
    }

    // --- Animation loop
    function animate(){
      if(isSpinning){
        angle += angularVelocity;
        angularVelocity *= 0.9925; // friction
        // when slow enough, stop and snap
        if(Math.abs(angularVelocity) < 0.0008){
          angularVelocity = 0; isSpinning = false;
          const idx = findIndexUnderPointer(angle);
          if(idx >= 0) snapToIndex(idx);
        }
      }
      draw();
      requestAnimationFrame(animate);
    }

    // --- UI behavior
    function renderList(){
      listEl.innerHTML = '';
      if(names.length===0){ listEl.textContent='(keine Namen)'; return; }
      names.forEach((n,i)=>{
        const row = document.createElement('div'); row.textContent = n;
        const del = document.createElement('button'); del.textContent='✖'; del.addEventListener('click', ()=>{ names.splice(i,1); updateColors(); renderList(); draw(); });
        row.appendChild(del); listEl.appendChild(row);
      });
    }

    applyBtn.addEventListener('click', ()=>{
      // Split input robustly on newlines, commas, semicolons or vertical bars
      const parsed = namesEl.value.split(/\s*(?:,|;|\r?\n|\|)\s*/).map(s => s.trim()).filter(Boolean);
      if(parsed.length > 0){ names = parsed.slice(); updateColors(); renderList(); draw();  }
      else { alert('Bitte mindestens einen Namen eingeben.'); }
    });

    shuffleBtn.addEventListener('click', ()=>{ for(let i=names.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [names[i],names[j]]=[names[j],names[i]] } updateColors(); renderList(); draw(); });

    clearBtn.addEventListener('click', ()=>{ if(!confirm('Alle Namen löschen?')) return; names=[]; updateColors(); renderList(); draw();  namesEl.value=''; });

    addRandomBtn.addEventListener('click', ()=>{ const sample = ['Anna','Bernd','Cem','Dora','Emil','Fatima','Gina','Hassan','Iris','Jonas','Klara','Lukas','Mia','Nico','Olga','Paul','Quinn','Rita','Sam','Tina']; for(let i=0;i<6;i++){ const s=sample[Math.floor(Math.random()*sample.length)]; names.push(s); } updateColors(); renderList(); draw(); });

    spinBtn.addEventListener('click', ()=>{
      if(names.length===0){ alert('Füge zuerst Namen hinzu.'); return; }
      if(isSpinning || isSnapping) return;
      spinBtn.disabled = true;
      const min = 0.25, max = 0.7;
      // random direction & velocity
      angularVelocity = (Math.random()*(max-min)+min) * (Math.random()<0.5?1:-1);
      isSpinning = true; 
      // re-enable when snap completes
    });

    downloadBtn.addEventListener('click', ()=>{ const blob = new Blob([document.documentElement.outerHTML],'text/html'); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'gluecksrad.html'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    // --- Tests (simple internal checks to validate index math)
    function runInternalTests(){
      const out = [];
      const saved = names.slice();
      const sample = ['Anna','Bernd','Cem','Dora','Emil','Fatima'];
      names = sample.slice(); updateColors(); renderList(); draw();
      const slice = TAU / names.length;

      out.push('Sample names: ' + names.join(', '));

      // Test A: for angle = 0, report which index is under pointer
      angle = 0; const idxA = findIndexUnderPointer(angle); out.push(`Angle=0 -> index=${idxA}, name=${names[idxA]}`);

      // Test B: for each index, construct angle that should center that index under the pointer
      const checks = [];
      for(let i=0;i<names.length;i++){
        const mid = i*slice + slice/2;
        const a = mod(POINTER - mid, TAU);
        const idx = findIndexUnderPointer(a);
        checks.push({targetIndex:i, computedIndex:idx, nameExpected:names[i], nameComputed:names[idx]});
      }
      out.push('Per-index snap-checks:');
      checks.forEach(c=> out.push(`  target=${c.targetIndex} (${c.nameExpected}) -> computed=${c.computedIndex} (${c.nameComputed})`));

      // restore
      names = saved.slice(); updateColors(); renderList(); draw();
      testOutput.textContent = out.join('\n');
    }

    runTestsBtn.addEventListener('click', runInternalTests);

    // --- Initialization & responsiveness
    function init(){ names = ['Anna','Bernd','Cem','Dora','Emil','Fatima']; updateColors(); renderList(); draw(); animate(); }
    function fitCanvas(){ const size = Math.min(520, Math.max(320, Math.floor(Math.min(window.innerWidth*0.45, 520)))); canvas.width = size; canvas.height = size; draw(); }
    window.addEventListener('resize', fitCanvas); fitCanvas(); init();
  </script>
</body>
</html>
